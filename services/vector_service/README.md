# Service: Vector Service

## Purpose

The Vector Service handles the generation of text embeddings and provides vector search capabilities. It uses the Gemini API to create embeddings for document chunks and queries, and leverages Supabase with the pgvector extension for storing and searching these embeddings.

## Key Functionalities

### Embedding Generation
-   Receives document chunks, validates them using the `DocumentChunk` model from `core.models`.
-   Calls the shared `GeminiClient` (`core.gemini_client`) to generate embeddings for the text content of these chunks via `gemini_client.generate_embeddings`.
-   Calls `GeminiClient` to generate an embedding for a given search query text via `gemini_client.generate_query_embedding`.

### Vector Storage
-   Upserts document chunks along with their generated embeddings into the `chunks` table in Supabase using `vector_ops.upsert_embeddings`. This table is expected to have a `vector` column compatible with pgvector (e.g., `vector(embedding_dim)`).

### Vector Search
-   Performs similarity searches against the stored vectors in the `chunks` table using a Supabase Remote Procedure Call (RPC).
-   The RPC function (default name: `match_document_chunks`) takes a query embedding, a match threshold (cosine similarity), and a match count (top_k) as parameters.
-   Supports filtering search results, for example, by `paper_id` if the RPC function is designed to handle it.

## API Endpoints

### `POST /embed`

-   **Description:** Receives a list of document chunks, generates embeddings for their content using the Gemini API, and then stores these chunks along with their embeddings in the Supabase `chunks` table.
-   **Request Body:** `EmbedRequest` (defined in `core.models`), which is essentially a list of dictionaries. Each dictionary should conform to the `DocumentChunk` model (excluding the `embedding` field, which is generated by this service).
    ```json
    {
      "chunks": [
        {
          "chunk_id": "string (UUID)",
          "paper_id": "string (UUID of the parent paper)",
          "text_content": "string (The actual text of the chunk)",
          "metadata": {
            "page_number": "integer (optional)",
            "sequence_in_paper": "integer (optional)"
          }
        }
        // ... more chunks
      ]
    }
    ```
-   **Response:** `EmbedResponse` (defined in `core.models`), which lists `processed_chunk_ids` and `failed_chunk_ids`.
    ```json
    {
      "processed_chunk_ids": ["uuid1", "uuid2"],
      "failed_chunk_ids": ["uuid3"]
    }
    ```
-   **Details:**
    1.  The input list of dictionaries is validated, and each valid item is converted into a `DocumentChunk` object.
    2.  For valid chunks, `gemini_client.generate_embeddings` is called to obtain vector embeddings for their `text_content`.
    3.  `vector_ops.upsert_embeddings` is then called to store these `DocumentChunk` objects (now including their embeddings) into the Supabase `chunks` table. This operation typically performs an "upsert" (update if exists, insert if not) based on `chunk_id`.

### `POST /search`

-   **Description:** Performs a semantic search for a given query text against the stored document chunk embeddings.
-   **Request Body:** `SearchQuery` (defined in `core.models`).
    ```json
    {
      "query_text": "string (The user's search query)",
      "top_k": "integer (Number of top matching results to return, e.g., 5)",
      "filters": {
        "paper_id": "string (Optional, UUID to filter results by a specific paper)"
      }
    }
    ```
-   **Response:** `SearchResponse` (defined in `core.models`), which is a list of `SearchResultItem` objects.
    ```json
    {
      "results": [
        {
          "chunk_id": "string (UUID of the matching chunk)",
          "paper_id": "string (UUID of the paper this chunk belongs to)",
          "text_content": "string (The content of the matching chunk)",
          "similarity_score": "float (Cosine similarity score)",
          "metadata": {
            "page_number": "integer (optional)"
          }
        }
        // ... more results
      ]
    }
    ```
-   **Details:**
    1.  `gemini_client.generate_query_embedding` is called to convert the `query_text` into a vector embedding.
    2.  `vector_ops.search_similar` is invoked. This function prepares parameters (query embedding, `top_k`, the `SEARCH_MATCH_THRESHOLD` from settings, and any provided filters) and calls the Supabase RPC function (e.g., `match_document_chunks`). The RPC function performs the actual similarity search in the database.

### `GET /health`

-   **Description:** Provides a basic health check for the Vector Service. It typically checks its own status and connectivity to critical dependencies like the Supabase database and the Gemini client.
-   **Response:** A JSON object indicating the service's health status.
    ```json
    {
      "status": "healthy",
      "dependencies": {
        "database_status": "connected",
        "gemini_client_status": "configured"
      }
    }
    ```

## Dependencies

### Core Module

-   `core.config.Settings`: For accessing configuration variables such as `SEARCH_MATCH_THRESHOLD`, Supabase/Gemini credentials, embedding dimensions, and logging settings.
-   `core.models`: Utilizes several Pydantic models for request/response validation and data structuring:
    -   `EmbedRequest`: For the `/embed` endpoint request.
    -   `EmbedResponse`: For the `/embed` endpoint response.
    -   `SearchQuery`: For the `/search` endpoint request.
    -   `SearchResponse`: For the `/search` endpoint response.
    -   `DocumentChunk`: Represents a piece of text from a document, including its embedding.
    -   `SearchResultItem`: Represents a single item in the search results.
-   `core.gemini_client.GeminiClient`: The shared client for interacting with the Google Gemini API to generate text and query embeddings.
-   `core.supabase_client.get_supabase_client`: Utility function to obtain an initialized Supabase client instance for database operations.

### Libraries

-   `fastapi`: The web framework used for building the service's API.
-   `uvicorn`: The ASGI server for running the FastAPI application.
-   `supabase-py`: The official Python client library for Supabase, used for database interactions, particularly for calling RPC functions (like `match_document_chunks`) and table operations (like upserting into the `chunks` table).
-   `pydantic`: For data validation through Pydantic models and for managing settings (via `core.config`).
-   `python-dotenv`: For managing environment variables (loaded via `core.config`).

## Configuration

The Vector Service relies on the following environment variables, managed by `core.config.Settings` and typically loaded from a `.env` file:

-   `GEMINI_API_KEY`: Required by `core.gemini_client` to authenticate with the Google Gemini API.
-   `SUPABASE_URL`: The URL of your Supabase project, required by `core.supabase_client`.
-   `SUPABASE_KEY` (or `SUPABASE_SERVICE_KEY`): The API key (preferably the service role key) for authenticating with Supabase, required by `core.supabase_client`.
-   `SEARCH_MATCH_THRESHOLD`: A float (e.g., `0.75`) representing the minimum cosine similarity score for a chunk to be considered a match in search results.
-   `EMBEDDING_DIM`: An integer (e.g., `768`) specifying the dimensionality of the embeddings generated by the Gemini model. This is indirectly used via `core.config` and must match the database schema (e.g., `vector(768)` in pgvector).
-   Standard logging configurations (e.g., `LOG_LEVEL`) inherited from `core.config`.
-   `DB_RPC_FUNCTION_NAME`: The name of the Supabase RPC function to call for similarity search (e.g., `match_document_chunks`).

## Database Interaction

The Vector Service interacts with the Supabase PostgreSQL database, primarily with the `chunks` table and a specific RPC function for searching.

-   **Table: `chunks`**
    -   This table is expected to store individual document chunks.
    -   Key columns include:
        -   `chunk_id` (or `id`): Primary key, typically UUID.
        -   `paper_id`: Foreign key referencing the `papers` table.
        -   `text_content` (or `content`): The actual text of the chunk.
        -   `embedding`: A column of type `vector(EMBEDDING_DIM)` (from pgvector extension) to store the generated text embedding.
        -   `metadata`: A JSONB column for any additional metadata about the chunk (e.g., page number, sequence).
    -   `vector_ops.upsert_embeddings(db: Client, chunks_with_embeddings: list[DocumentChunk])`:
        -   Takes a list of `DocumentChunk` objects (which now include their `embedding` attribute).
        -   Performs an "upsert" operation into the `chunks` table. This means if a chunk with the same `chunk_id` already exists, it's updated; otherwise, a new record is inserted.

-   **Supabase RPC Function (e.g., `match_document_chunks`)**
    -   `vector_ops.search_similar(...)` calls this pre-defined SQL function in Supabase.
    -   This function is responsible for performing the vector similarity search.
    -   Expected parameters typically include:
        -   `query_embedding`: The vector embedding of the search query.
        -   `match_threshold`: A float for the minimum similarity score.
        -   `match_count`: An integer for the maximum number of results to return (top_k).
        -   `filter_paper_id` (optional): A text value (UUID) to filter chunks belonging to a specific paper.
    -   The function uses pgvector's operators (e.g., `<=>` for cosine distance) to compare the `query_embedding` with the `embedding` column in the `chunks` table.
    -   It should return a set of rows, each containing at least `chunk_id` (or `id`), `paper_id`, `text_content` (or `content`), `metadata`, and the calculated `similarity` score. The `SearchResultItem` model in `core.models` should align with the structure of data returned by this RPC.
